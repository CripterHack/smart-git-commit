"""
Git Hooks Integration - Module for integrating Smart Git Commit as Git hooks.

This module provides functionality to run Smart Git Commit as part of Git workflows
through Git hooks, with support for both native Git hooks and Husky integration.
"""

import os
import sys
import stat
import logging
import platform
import subprocess
from pathlib import Path
from typing import List, Dict, Optional, Union, Tuple
import shutil

logger = logging.getLogger(__name__)

# Hook types supported by this module
SUPPORTED_HOOKS = [
    "pre-commit",
    "pre-push",
    "post-merge",
    "post-checkout",
    "post-rewrite",
    "commit-msg"  # Adding commit-msg to fix test failures
]

# Templates for hook scripts
HOOK_SCRIPT_TEMPLATE = """#!/usr/bin/env {shell}
# Smart Git Commit Hook
# Automatically generated by smart-git-commit v{version}

{imports}

# Check if this hook should be skipped
if [ -n "$SKIP_SMART_GIT_COMMIT_HOOKS" ]; then
    echo "Smart Git Commit hooks skipped (SKIP_SMART_GIT_COMMIT_HOOKS is set)"
    exit 0
fi

# Run Smart Git Commit
echo "Running Smart Git Commit as {hook_type} hook..."
{command}
RESULT=$?

if [ $RESULT -ne 0 ]; then
    echo "Smart Git Commit hook failed with exit code $RESULT"
    exit $RESULT
fi

exit 0
"""

WINDOWS_HOOK_SCRIPT_TEMPLATE = """@echo off
:: Smart Git Commit Hook
:: Automatically generated by smart-git-commit v{version}

:: Check if this hook should be skipped
if defined SKIP_SMART_GIT_COMMIT_HOOKS (
    echo Smart Git Commit hooks skipped (SKIP_SMART_GIT_COMMIT_HOOKS is set)
    exit /b 0
)

:: Run Smart Git Commit
echo Running Smart Git Commit as {hook_type} hook...
{command}
if %ERRORLEVEL% neq 0 (
    echo Smart Git Commit hook failed with exit code %ERRORLEVEL%
    exit /b %ERRORLEVEL%
)

exit /b 0
"""

# Husky configuration templates
HUSKY_CONFIG_TEMPLATE = """
{
  "hooks": {
    "pre-commit": "smart-git-commit hook pre-commit $@",
    "pre-push": "smart-git-commit hook pre-push $@"
  }
}
"""

HUSKY_PACKAGE_JSON_TEMPLATE = """
{
  "name": "smart-git-commit-hooks",
  "version": "1.0.0",
  "private": true,
  "husky": %s
}
"""

class GitHook:
    """
    Class for managing Git hooks in a repository.
    
    This class provides functionality to:
    1. Check if a hook is installed
    2. Install hook scripts with customization options
    3. Remove hooks with optional backup/restore
    """
    
    def __init__(self, repo_path: str, hook_type: str, hooks_dir: str = None):
        """
        Initialize a GitHook instance.
        
        Args:
            repo_path: Path to the Git repository
            hook_type: Type of Git hook (e.g., pre-commit, pre-push)
            hooks_dir: Custom hooks directory (optional)
        
        Raises:
            ValueError: If hook_type is not supported or repo_path is not a Git repository
        """
        if hook_type not in SUPPORTED_HOOKS:
            raise ValueError(f"Unsupported hook type: {hook_type}")
        
        self.repo_path = os.path.abspath(repo_path)
        self.hook_type = hook_type
        
        git_root = get_git_root(self.repo_path)
        if not git_root:
            raise ValueError(f"Not a Git repository: {self.repo_path}")
        
        self.hooks_dir = hooks_dir or get_git_hooks_dir(self.repo_path)
        if not self.hooks_dir:
            raise ValueError(f"Could not find Git hooks directory for {self.repo_path}")
        
        self.hook_path = os.path.join(self.hooks_dir, hook_type)
        if is_windows():
            self.hook_path_with_ext = f"{self.hook_path}.bat"
        else:
            self.hook_path_with_ext = self.hook_path
    
    def is_installed(self) -> bool:
        """
        Check if the hook is installed.
        
        Returns:
            True if the hook is installed and executable, False otherwise
        """
        return is_hook_installed(self.hook_type, self.repo_path)
    
    def is_smart_git_commit_hook(self) -> bool:
        """
        Check if the installed hook is a Smart Git Commit hook.
        
        Returns:
            True if the hook is a Smart Git Commit hook, False otherwise
        """
        try:
            if os.path.exists(self.hook_path_with_ext):
                with open(self.hook_path_with_ext, 'r') as f:
                    content = f.read()
                return "Smart Git Commit Hook" in content or "smart-git-commit" in content
        except IOError as e:
            logger.error(f"Error reading hook file: {str(e)}")
        
        return False
    
    def install(self, script: str = None, template: str = None, 
                force: bool = False, backup: bool = False, 
                permissions: int = None) -> bool:
        """
        Install the hook script.
        
        Args:
            script: Custom script content (optional)
            template: Custom template for script generation (optional)
            force: Whether to overwrite existing hook (default: False)
            backup: Whether to backup existing hook (default: False)
            permissions: Custom permissions for the hook file (optional)
        
        Returns:
            True if successful, False otherwise
        """
        # Check if hook exists and handle based on force/backup options
        if os.path.exists(self.hook_path_with_ext) and not force:
            if not backup:
                logger.warning(f"Hook {self.hook_type} already exists. Use force=True to overwrite.")
                return False
            
            # Create backup
            backup_path = f"{self.hook_path_with_ext}.bak"
            try:
                # Use shutil.copy2 to preserve metadata like permissions
                shutil.copy2(self.hook_path_with_ext, backup_path)
                logger.info(f"Created backup of existing hook at {backup_path}")
            except IOError as e:
                logger.error(f"Error creating backup: {str(e)}")
                return False
        
        # Generate script content
        if script is None:
            script = get_hook_script(self.hook_type, template=template, variables=self._get_script_variables())

        # Write the script
        try:
            os.makedirs(os.path.dirname(self.hook_path_with_ext), exist_ok=True)
            with open(self.hook_path_with_ext, 'w') as f:
                f.write(script)
            
            # Set permissions
            effective_permissions = permissions
            if effective_permissions is None and not is_windows():
                effective_permissions = 0o755 # Default executable
            
            if effective_permissions is not None:
                os.chmod(self.hook_path_with_ext, effective_permissions)
            
            logger.info(f"Installed {self.hook_type} hook at {self.hook_path_with_ext}")
            return True
        except IOError as e:
            logger.error(f"Error writing hook script: {str(e)}")
            return False
    
    def remove(self, restore_backup: bool = False, cleanup: bool = False) -> bool:
        """
        Remove the hook script.
        
        Args:
            restore_backup: Whether to restore from backup if available (default: False)
            cleanup: Whether to remove related files like backups (default: False)
        
        Returns:
            True if successful, False otherwise
        """
        backup_path = f"{self.hook_path_with_ext}.bak"
        
        # Check if we should restore from backup
        if restore_backup and os.path.exists(backup_path):
            try:
                # Use shutil.move for atomic restore (replace existing hook)
                shutil.move(backup_path, self.hook_path_with_ext)
                logger.info(f"Restored {self.hook_type} hook from backup")
                return True
            except IOError as e:
                logger.error(f"Error restoring from backup: {str(e)}")
                # If restore failed, still try to remove the main hook if it exists
                pass # Fall through to normal removal
        
        # Remove the hook file
        removed = False
        try:
            if os.path.exists(self.hook_path_with_ext):
                os.remove(self.hook_path_with_ext)
                logger.info(f"Removed {self.hook_type} hook")
                removed = True
            else:
                 removed = True # Already gone
            
            # Cleanup related files if requested
            if cleanup:
                related_files = self.get_all_backup_files()
                for file_path in related_files:
                    if os.path.exists(file_path):
                        os.remove(file_path)
                        logger.info(f"Removed related file: {file_path}")
            
            return removed
        except IOError as e:
            logger.error(f"Error removing hook: {str(e)}")
            return False
    
    def get_script_content(self) -> Optional[str]:
        """
        Get the content of the hook script.
        
        Returns:
            The script content as string, or None if the hook is not installed
        """
        try:
            if os.path.exists(self.hook_path_with_ext):
                with open(self.hook_path_with_ext, 'r') as f:
                    return f.read()
        except IOError as e:
            logger.error(f"Error reading hook script: {str(e)}")
        
        return None
    
    def get_all_backup_files(self) -> List[str]:
        """
        Get a list of all backup and temporary files related to this hook.
        
        Returns:
            List of file paths
        """
        result = []
        base_path, _ = os.path.splitext(self.hook_path_with_ext)
        hooks_dir = os.path.dirname(self.hook_path_with_ext)
        hook_base_name = os.path.basename(base_path)
        
        try:
             for filename in os.listdir(hooks_dir):
                 if filename.startswith(hook_base_name) and filename != os.path.basename(self.hook_path_with_ext):
                     # Check for common backup extensions
                     if any(filename.endswith(ext) for ext in ['.bak', '.tmp', '.old', '.backup']):
                         result.append(os.path.join(hooks_dir, filename))
        except OSError as e:
             logger.error(f"Error listing backup files: {e}")
        
        return result
    
    def _format_script(self, template: str) -> str:
        """
        Format a script template with hook variables.
        
        Args:
            template: Script template with variable placeholders
        
        Returns:
            Formatted script with variables replaced
        """
        variables = self._get_script_variables()
        return format_hook_script(template, variables) # Use standalone formatter
        
    def _get_script_variables(self) -> Dict[str, str]:
        """
        Get variables needed for formatting hook scripts.
        
        Returns:
            Dictionary of script variables
        """
        git_dir = os.path.join(get_git_root(self.repo_path), ".git")
        return {
            "repo_path": self.repo_path,
            "hook_type": self.hook_type,
            "git_dir": git_dir,
            "hooks_dir": self.hooks_dir,
            "script_path": self.hook_path_with_ext,
            "command": get_smart_git_commit_command(self.hook_type),
            "version": "0.3.4", # TODO: Get version dynamically
            "shell": get_shell(),
            "is_windows": str(is_windows()).lower()
        }

def is_windows() -> bool:
    """Check if the current OS is Windows."""
    return platform.system() == "Windows"

def get_shell() -> str:
    """Get the appropriate shell for the current platform."""
    if is_windows():
        return "cmd"
    return "bash"

def get_git_root(path: str = ".") -> Optional[str]:
    """
    Get the root directory of the Git repository containing the specified path.
    Returns None if the path is not in a Git repository.
    """
    try:
        result = subprocess.run(
            ["git", "-C", path, "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=True
        )
        # Normalize the path before returning
        return os.path.normpath(result.stdout.strip())
    except subprocess.CalledProcessError:
        return None

def get_git_hooks_dir(repo_path: str = ".") -> Optional[str]:
    """
    Get the directory where Git hooks are stored for the repository.
    Returns None if not in a Git repository.
    """
    git_root = get_git_root(repo_path)
    if not git_root:
        return None
    
    # Check if a custom hooks path is configured
    try:
        result = subprocess.run(
            ["git", "-C", repo_path, "config", "core.hooksPath"],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0 and result.stdout.strip():
            hooks_path = result.stdout.strip()
            # If the path is relative, it's relative to the git dir
            if not os.path.isabs(hooks_path):
                hooks_path = os.path.join(git_root, ".git", hooks_path)
            return hooks_path
    except subprocess.CalledProcessError:
        pass
    
    # Default hooks location
    return os.path.join(git_root, ".git", "hooks")

def get_smart_git_commit_command(hook_type: str) -> str:
    """
    Generate the command to run Smart Git Commit with the appropriate options
    for the specified hook type.
    """
    base_cmd = "smart-git-commit"
    
    # Add arguments specific to the hook type
    if hook_type == "pre-commit":
        return f"{base_cmd} --non-interactive"
    elif hook_type == "pre-push":
        return f"{base_cmd} --non-interactive --analyze-only"
    elif hook_type in ("post-merge", "post-checkout", "post-rewrite"):
        return f"{base_cmd} --non-interactive --analyze-only"
    else:
        return base_cmd

def create_hook_script(
    hook_type: str, 
    target_dir: str, 
    version: str = "0.3.4"
) -> Optional[str]:
    """
    Create a Git hook script for the specified hook type.
    Returns the path to the created script if successful, None otherwise.
    """
    if hook_type not in SUPPORTED_HOOKS:
        logger.error(f"Unsupported hook type: {hook_type}")
        return None
    
    # Ensure the target directory exists
    os.makedirs(target_dir, exist_ok=True)
    
    # Generate the appropriate command for this hook type
    command = get_smart_git_commit_command(hook_type)
    
    # Create the script content
    if is_windows():
        script_content = WINDOWS_HOOK_SCRIPT_TEMPLATE.format(
            version=version,
            hook_type=hook_type,
            command=command
        )
        file_extension = ".bat"
    else:
        imports = "# Import needed functions\nimport_path=\"$(dirname \"$0\")/../lib/smart_git_commit\"\nif [ -f \"$import_path\" ]; then\n    source \"$import_path\"\nfi"
        script_content = HOOK_SCRIPT_TEMPLATE.format(
            shell=get_shell(),
            version=version,
            imports=imports,
            hook_type=hook_type,
            command=command
        )
        file_extension = ""
    
    # Write the script to the target location
    script_path = os.path.join(target_dir, f"{hook_type}{file_extension}")
    try:
        with open(script_path, "w") as f:
            f.write(script_content)
        
        # Make the script executable on Unix systems
        if not is_windows():
            os.chmod(script_path, os.stat(script_path).st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
        
        logger.info(f"Created {hook_type} hook at {script_path}")
        return script_path
    except Exception as e:
        logger.error(f"Error creating hook script: {e}")
        return None

def install_git_hooks(
    repo_path: str = ".", 
    hooks: List[str] = None,
    version: str = "0.3.4",
    script: str = None,
    force: bool = False,
    backup: bool = False
) -> Dict[str, bool]:
    """
    Install Git hooks for Smart Git Commit.
    
    Args:
        repo_path: Path to the Git repository
        hooks: List of hook types to install (default: ["pre-commit", "pre-push"])
        version: Version string to include in the hook script
        script: Custom script content (optional)
        force: Whether to overwrite existing hooks
        backup: Whether to backup existing hooks before overwriting
        
    Returns:
        Dictionary with hook names as keys and installation success as values
    """
    if not hooks:
        hooks = ["pre-commit", "pre-push"]
    
    hooks_dir = get_git_hooks_dir(repo_path)
    if not hooks_dir:
        logger.error(f"Could not find Git hooks directory for {repo_path}")
        return {hook: False for hook in hooks}
    
    results = {}
    for hook_type in hooks:
        if hook_type not in SUPPORTED_HOOKS:
            logger.warning(f"Unsupported hook type: {hook_type}")
            results[hook_type] = False
            continue
        
        # Use the install_hook function for more flexibility
        if script:
            # Use custom script if provided
            results[hook_type] = install_hook(hooks_dir, hook_type, script, force, backup)
        else:
            # Create the script using the template
            hook_script = get_hook_script(hook_type)
            results[hook_type] = install_hook(hooks_dir, hook_type, hook_script, force, backup)
    
    return results

def remove_git_hooks(
    repo_path: str = ".", 
    hooks: List[str] = None,
    restore_backup: bool = False
) -> Dict[str, bool]:
    """
    Remove Git hooks for Smart Git Commit.
    
    Args:
        repo_path: Path to the Git repository
        hooks: List of hook types to remove (default: all supported hooks)
        restore_backup: Whether to restore from backup if available
        
    Returns:
        Dictionary with hook names as keys and removal success as values
    """
    if not hooks:
        hooks = SUPPORTED_HOOKS
    
    hooks_dir = get_git_hooks_dir(repo_path)
    if not hooks_dir:
        logger.error(f"Could not find Git hooks directory for {repo_path}")
        return {hook: False for hook in hooks}
    
    results = {}
    for hook_type in hooks:
        if hook_type not in SUPPORTED_HOOKS:
            logger.warning(f"Unsupported hook type: {hook_type}")
            results[hook_type] = False
            continue
        
        # Use the remove_hook function for more flexibility
        results[hook_type] = remove_hook(hooks_dir, hook_type, restore_backup)
    
    return results

def check_husky_compatibility() -> Tuple[bool, str]:
    """
    Check if Husky can be used in the current environment.
    Returns a tuple of (is_compatible, reason).
    """
    # Check if npm is available
    try:
        subprocess.run(["npm", "--version"], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False, "npm is not available in the current environment"
    
    # Check if we're in a Git repository
    git_root = get_git_root()
    if not git_root:
        return False, "Not in a Git repository"
    
    # Check if package.json exists (Node.js project)
    package_json_path = os.path.join(git_root, "package.json")
    if not os.path.exists(package_json_path):
        return True, "No package.json found. Will need to create one for Husky."
    
    return True, "Husky can be used in this environment"

def install_husky(repo_path: str = ".") -> bool:
    """
    Install and configure Husky for the Git repository.
    Returns True if successful, False otherwise.
    """
    # First, check if Husky can be used
    is_compatible, reason = check_husky_compatibility()
    if not is_compatible:
        logger.error(f"Husky cannot be installed: {reason}")
        return False
    
    git_root = get_git_root(repo_path)
    if not git_root:
        logger.error("Not in a Git repository")
        return False
    
    try:
        # Check if package.json exists
        package_json_path = os.path.join(git_root, "package.json")
        create_package_json = not os.path.exists(package_json_path)
        
        if create_package_json:
            # Create a minimal package.json
            with open(package_json_path, "w") as f:
                husky_config = HUSKY_CONFIG_TEMPLATE.strip()
                f.write(HUSKY_PACKAGE_JSON_TEMPLATE % husky_config)
            logger.info(f"Created package.json at {package_json_path}")
        else:
            # Update existing package.json to add husky config
            import json
            with open(package_json_path, "r") as f:
                package_data = json.load(f)
            
            # Add husky configuration
            husky_config = json.loads(HUSKY_CONFIG_TEMPLATE)
            package_data["husky"] = husky_config
            
            with open(package_json_path, "w") as f:
                json.dump(package_data, f, indent=2)
            logger.info(f"Updated package.json at {package_json_path} with husky configuration")
        
        # Install husky
        subprocess.run(["npm", "install", "husky", "--save-dev"], cwd=git_root, check=True)
        logger.info("Installed husky package")
        
        # Verify husky installation
        hooks_path = os.path.join(git_root, ".husky")
        if not os.path.exists(hooks_path):
            logger.warning("Husky directory not found after installation. Setting up manually.")
            # Initialize husky manually
            subprocess.run(["npx", "husky", "install"], cwd=git_root, check=True)
        
        # Add hooks
        for hook_type in ["pre-commit", "pre-push"]:
            cmd = get_smart_git_commit_command(hook_type)
            subprocess.run(
                ["npx", "husky", "add", f".husky/{hook_type}", cmd],
                cwd=git_root,
                check=True
            )
            logger.info(f"Added {hook_type} hook with husky")
        
        return True
    
    except Exception as e:
        logger.error(f"Error installing husky: {e}")
        return False

def remove_husky(repo_path: str = ".") -> bool:
    """
    Remove Husky configuration and hooks.
    Returns True if successful, False otherwise.
    """
    git_root = get_git_root(repo_path)
    if not git_root:
        logger.error("Not in a Git repository")
        return False
    
    try:
        # Check if .husky directory exists
        husky_dir = os.path.join(git_root, ".husky")
        if os.path.exists(husky_dir):
            # Remove smart-git-commit hooks
            for hook_type in ["pre-commit", "pre-push"]:
                hook_path = os.path.join(husky_dir, hook_type)
                if os.path.exists(hook_path):
                    with open(hook_path, "r") as f:
                        content = f.read()
                    
                    if "smart-git-commit" in content:
                        os.remove(hook_path)
                        logger.info(f"Removed {hook_type} hook from husky")
        
        # Update package.json if it exists
        package_json_path = os.path.join(git_root, "package.json")
        if os.path.exists(package_json_path):
            import json
            with open(package_json_path, "r") as f:
                package_data = json.load(f)
            
            # Remove husky configuration
            if "husky" in package_data:
                del package_data["husky"]
                
                with open(package_json_path, "w") as f:
                    json.dump(package_data, f, indent=2)
                logger.info(f"Removed husky configuration from package.json")
        
        return True
    
    except Exception as e:
        logger.error(f"Error removing husky: {e}")
        return False

def run_hook(hook_type: str, args: List[str] = None) -> int:
    """
    Run Smart Git Commit as a Git hook.
    Returns the exit code from the process.
    """
    if hook_type not in SUPPORTED_HOOKS:
        logger.error(f"Unsupported hook type: {hook_type}")
        return 1
    
    # Build the command with appropriate arguments
    cmd_args = ["smart-git-commit"]
    
    # Add hook-specific arguments
    if hook_type == "pre-commit":
        cmd_args.extend(["--non-interactive"])
    elif hook_type == "pre-push":
        cmd_args.extend(["--non-interactive", "--analyze-only"])
    
    # Add any additional arguments
    if args:
        cmd_args.extend(args)
    
    try:
        logger.info(f"Running Smart Git Commit as {hook_type} hook: {' '.join(cmd_args)}")
        process = subprocess.run(cmd_args)
        return process.returncode
    except Exception as e:
        logger.error(f"Error running hook: {e}")
        return 1

def is_hook_installed(hook_type: str, repo_path: str = ".") -> bool:
    """
    Check if a specific hook is installed.
    Returns True if the hook is installed, False otherwise.
    """
    # First check native Git hooks
    hooks_dir = get_git_hooks_dir(repo_path)
    if hooks_dir:
        for ext in ["", ".bat"]:
            hook_path = os.path.join(hooks_dir, f"{hook_type}{ext}")
            if os.path.exists(hook_path):
                with open(hook_path, "r") as f:
                    content = f.read()
                if "Smart Git Commit Hook" in content:
                    return True
    
    # Check Husky hooks
    git_root = get_git_root(repo_path)
    if git_root:
        husky_hook_path = os.path.join(git_root, ".husky", hook_type)
        if os.path.exists(husky_hook_path):
            with open(husky_hook_path, "r") as f:
                content = f.read()
            if "smart-git-commit" in content:
                return True
    
    return False

def list_installed_hooks(repo_path: str = ".") -> Dict[str, str]:
    """
    List all installed hooks in a repository.
    
    Args:
        repo_path: Path to the Git repository
        
    Returns:
        Dictionary mapping hook names to their types (native/husky)
    """
    result = {}
    
    try:
        # Check native Git hooks
        hooks_dir = get_git_hooks_dir(repo_path)
        if hooks_dir:
            for hook_type in SUPPORTED_HOOKS:
                for ext in ["", ".bat"]:
                    hook_path = os.path.join(hooks_dir, f"{hook_type}{ext}")
                    if os.path.exists(hook_path):
                        with open(hook_path, "r") as f:
                            content = f.read()
                        if "Smart Git Commit Hook" in content:
                            result[hook_type] = "native"
                            break
        
        # Check Husky hooks
        git_root = get_git_root(repo_path)
        if git_root:
            husky_dir = os.path.join(git_root, ".husky")
            if os.path.exists(husky_dir):
                for hook_type in SUPPORTED_HOOKS:
                    hook_path = os.path.join(husky_dir, hook_type)
                    if os.path.exists(hook_path):
                        with open(hook_path, "r") as f:
                            content = f.read()
                        if "smart-git-commit" in content:
                            result[hook_type] = "husky"
        
        return result
    except Exception as e:
        logger.error(f"Error listing installed hooks: {e}")
        return {}

def get_hook_path(hooks_dir: str, hook_type: str) -> str:
    """
    Get the full path to a hook file.
    
    Args:
        hooks_dir: Directory containing hooks
        hook_type: Type of hook (e.g., pre-commit)
        
    Returns:
        Full path to the hook file
    """
    if is_windows():
        return os.path.join(hooks_dir, f"{hook_type}.bat")
    else:
        return os.path.join(hooks_dir, hook_type)

def get_hook_types() -> List[str]:
    """
    Get a list of all supported hook types.
    
    Returns:
        List of hook type names
    """
    return SUPPORTED_HOOKS.copy()

def validate_hook_type(hook_type: str) -> bool:
    """
    Validate that a hook type is supported.
    
    Args:
        hook_type: Type of hook to validate
        
    Returns:
        True if the hook type is supported, False otherwise
    """
    return hook_type in SUPPORTED_HOOKS

def get_hook_script(hook_type: str, template: str = None, variables: Dict[str, str] = None, validate: bool = False) -> str:
    """
    Get the script content for a specific hook type.
    
    Args:
        hook_type: Type of hook (e.g., pre-commit)
        template: Custom template for the script (optional)
        variables: Variables to substitute in the template (optional)
        validate: Whether to validate the script before returning it (optional)
        
    Returns:
        Script content as a string
        
    Raises:
        ValueError: If hook_type is not supported or if validation fails
    """
    if hook_type not in SUPPORTED_HOOKS:
        raise ValueError(f"Unsupported hook type: {hook_type}")
    
    # Get script content
    if template is None:
        # Use default template
        version = "0.3.4"  # TODO: Get from package version
        command = get_smart_git_commit_command(hook_type)
        
        if is_windows():
            script = WINDOWS_HOOK_SCRIPT_TEMPLATE.format(
                version=version,
                hook_type=hook_type,
                command=command
            )
        else:
            imports = "# Import needed functions\nimport_path=\"$(dirname \"$0\")/../lib/smart_git_commit\"\nif [ -f \"$import_path\" ]; then\n    source \"$import_path\"\nfi"
            script = HOOK_SCRIPT_TEMPLATE.format(
                shell=get_shell(),
                version=version,
                imports=imports,
                hook_type=hook_type,
                command=command
            )
    else:
        # Use custom template
        if variables is None:
            variables = {
                "hook_type": hook_type,
                "command": get_smart_git_commit_command(hook_type),
                "version": "0.3.4",  # TODO: Get from package version
                "shell": get_shell(),
                "is_windows": str(is_windows()).lower()
            }
        
        # Format template
        script = format_hook_script(template, variables)
    
    # Validate script if requested
    if validate:
        # Check for required components
        if "smart-git-commit" not in script and "Smart Git Commit" not in script:
            raise ValueError("Invalid hook script: Missing smart-git-commit command")
    
    return script

def format_hook_script(template: str, variables: Dict[str, str]) -> str:
    """
    Format a hook script template with variables.
    
    Args:
        template: Script template with placeholders like {variable_name}
        variables: Dictionary of variable names and values
        
    Returns:
        Formatted script with variables substituted
    """
    result = template
    for var_name, var_value in variables.items():
        result = result.replace(f"{{{var_name}}}", str(var_value))
    
    return result

def install_hook(hooks_dir: str, hook_type: str, script: str = None, 
                 force: bool = False, backup: bool = False,
                 permissions: int = None) -> bool:
    """
    Install a Git hook script.
    
    Args:
        hooks_dir: Directory containing hooks
        hook_type: Type of hook to install
        script: Custom script content (optional)
        force: Whether to overwrite existing hook (optional)
        backup: Whether to backup existing hook (optional)
        permissions: Custom permissions for the hook file (optional)
        
    Returns:
        True if the hook was installed successfully, False otherwise
    """
    # Validate hook type
    if not validate_hook_type(hook_type):
        logger.error(f"Unsupported hook type: {hook_type}")
        return False
    
    # Get hook path
    hook_path = get_hook_path(hooks_dir, hook_type)
    
    # Check if hook exists
    if os.path.exists(hook_path) and not force:
        if not backup:
            logger.warning(f"Hook {hook_type} already exists. Use force=True to overwrite.")
            return False
        
        # Create backup
        backup_path = f"{hook_path}.bak"
        try:
            shutil.copy2(hook_path, backup_path)
            logger.info(f"Created backup of existing hook at {backup_path}")
        except IOError as e:
            logger.error(f"Error creating backup: {str(e)}")
            return False
    
    # Get script content
    if script is None:
        try:
            script = get_hook_script(hook_type)
        except ValueError as e:
            logger.error(str(e))
            return False
    
    # Write script to file
    try:
        # Create hooks directory if it doesn't exist
        os.makedirs(os.path.dirname(hook_path), exist_ok=True)
        
        with open(hook_path, 'w') as f:
            f.write(script)
        
        # Set executable permission
        if permissions is None:
            if not is_windows():
                os.chmod(hook_path, 0o755)
        else:
            os.chmod(hook_path, permissions)
        
        logger.info(f"Created {hook_type} hook at {hook_path}")
        return True
    except Exception as e:
        logger.error(f"Error installing hook: {str(e)}")
        return False

def remove_hook(hooks_dir: str, hook_type: str, restore_backup: bool = False) -> bool:
    """
    Remove a Git hook script.
    
    Args:
        hooks_dir: Directory containing hooks
        hook_type: Type of hook to remove
        restore_backup: Whether to restore from backup if available
        
    Returns:
        True if the hook was removed or not present, False on error
    """
    # Validate hook type
    if not validate_hook_type(hook_type):
        logger.error(f"Unsupported hook type: {hook_type}")
        return False
    
    # Get hook path
    hook_path = get_hook_path(hooks_dir, hook_type)
    
    # Check if hook exists
    if not os.path.exists(hook_path):
        logger.info(f"Hook {hook_type} not found.")
        return True  # Not an error, hook is already gone
    
    # Check if we should restore from backup
    backup_path = f"{hook_path}.bak"
    if restore_backup and os.path.exists(backup_path):
        try:
            # Restore backup first, then delete backup file
            shutil.copy2(backup_path, hook_path)
            os.remove(backup_path)
            logger.info(f"Restored {hook_type} hook from backup")
            return True
        except IOError as e:
            logger.error(f"Error restoring from backup: {str(e)}")
            return False
    
    # Remove hook
    try:
        os.remove(hook_path)
        logger.info(f"Removed hook {hook_path}")
        return True
    except Exception as e:
        logger.error(f"Error removing hook: {str(e)}")
        return False 